/**
 * PID Line Follower for Arduino
 * Uses Cytron 5 IR array sensor and TB6612FNG motor driver
 */

// Pin definitions for TB6612FNG motor driver
// Motor A - Left Motor
#define AIN1 5
#define AIN2 4
#define PWMA 3

// Motor B - Right Motor
#define BIN1 6
#define BIN2 7
#define PWMB 8

// Pin definitions for Cytron 5 IR array sensor (digital inputs)
#define IR1 18  // Leftmost sensor
#define IR2 19  // Left sensor
#define IR3 20  // Middle sensor
#define IR4 21  // Right sensor
#define IR5 22  // Rightmost sensor

// PID Constants - adjust these based on your robot's characteristics
#define KP 30  // Proportional gain   prev=28
#define KI 0.01   // Integral gain
#define KD 40  // Derivative gain      prev= 25

// Motor speed constants
#define BASE_SPEED 80    // Base speed (0-255)
#define MAX_SPEED 255     // Maximum speed (0-255)

// Variables for PID calculation
float lastError = 0;
float integral = 0;

void setup() {
  // Initialize serial communication
  Serial.begin(9600);
  
  // Set motor driver pins as outputs
  pinMode(AIN1, OUTPUT);
  pinMode(AIN2, OUTPUT);
  pinMode(PWMA, OUTPUT);
  pinMode(BIN1, OUTPUT);
  pinMode(BIN2, OUTPUT);
  pinMode(PWMB, OUTPUT);
  
  // Set IR sensor pins as inputs
  pinMode(IR1, INPUT);
  pinMode(IR2, INPUT);
  pinMode(IR3, INPUT);
  pinMode(IR4, INPUT);
  pinMode(IR5, INPUT);
  
  // Wait for 2 seconds before starting
  Serial.println("PID Line Follower Starting...");
  delay(2000);
}

void loop() {
  // Read sensor values
  int sensorValues[5];
  readSensors(sensorValues);
  
  // Calculate error and apply PID control
  float error = calculateError(sensorValues);
  
  // Calculate PID components
  float proportional = error;
  integral += error;
  float derivative = error - lastError;
  
  // Apply anti-windup to integral term
  integral = constrain(integral, -100, 100);
  
  // Calculate PID output
  float pidOutput = (KP * proportional) + (KI * integral) + (KD * derivative);
  
  // Update lastError for next iteration
  lastError = error;
  
  // Calculate motor speeds
  int leftSpeed = BASE_SPEED - pidOutput;
  int rightSpeed = BASE_SPEED + pidOutput;
  
  // Set motor speeds
  setMotors(leftSpeed, rightSpeed);
  
  // Print debug information
  /*Serial.print("Sensors: ");
  for (int i = 0; i < 5; i++) {
    Serial.print(sensorValues[i]);
    Serial.print(" ");
  }
  Serial.print("Error: ");
  Serial.println(error, 2);
  */
  // Small delay
  delay(10);  // 10ms loop time
}

void readSensors(int sensorValues[]) {
  // Read the IR sensors (0 for white, 1 for black)
  sensorValues[0] = digitalRead(IR1);
  sensorValues[1] = digitalRead(IR2);
  sensorValues[2] = digitalRead(IR3);
  sensorValues[3] = digitalRead(IR4);
  sensorValues[4] = digitalRead(IR5);
}

float calculateError(int sensorValues[]) {
  float position = 0;
  int sensorsSum = sensorValues[0] + sensorValues[1] + sensorValues[2] + sensorValues[3] + sensorValues[4];
  
  // If all sensors read white (0), maintain last error
  if (sensorsSum == 0) {
    return lastError;
  }
  
  // Calculate weighted position
  float weightedSum = (sensorValues[0] * -3.5 + 
                      sensorValues[1] * -1.5 + 
                      sensorValues[2] * 0.0 + 
                      sensorValues[3] * 1.5 + 
                      sensorValues[4] * 3.5);
  
  // Calculate normalized position
  position = weightedSum / sensorsSum;
  
  return position;
}

void setMotors(int leftSpeed, int rightSpeed) {
  // Constrain motor speeds
  leftSpeed = constrain(leftSpeed, -MAX_SPEED, MAX_SPEED);
  rightSpeed = constrain(rightSpeed, -MAX_SPEED, MAX_SPEED);
  
  // Set left motor direction and speed
  if (leftSpeed >= 0) {
    digitalWrite(AIN1, HIGH);  // Forward
    digitalWrite(AIN2, LOW);
    analogWrite(PWMA, leftSpeed);
  } else {
    digitalWrite(AIN1, LOW);   // Reverse
    digitalWrite(AIN2, HIGH);
    analogWrite(PWMA, -leftSpeed);
  }
  
  // Set right motor direction and speed
  if (rightSpeed >= 0) {
    digitalWrite(BIN1, HIGH);  // Forward
    digitalWrite(BIN2, LOW);
    analogWrite(PWMB, rightSpeed);
  } else {
    digitalWrite(BIN1, LOW);   // Reverse
    digitalWrite(BIN2, HIGH);
    analogWrite(PWMB, -rightSpeed);
  }
}

void stopMotors() {
  // Stop both motors
  analogWrite(PWMA, 0);
  analogWrite(PWMB, 0);
  digitalWrite(AIN1, LOW);
  digitalWrite(AIN2, LOW);
  digitalWrite(BIN1, LOW);
  digitalWrite(BIN2, LOW);
}
